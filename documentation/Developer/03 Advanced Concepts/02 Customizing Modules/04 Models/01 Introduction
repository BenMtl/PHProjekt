The model is the base of the module. It define all the logic and the interaction with the database.

In general, a module is an extension of the Phprojekt_Item_Abstract class, that provide all the necessaries functions.
If this is your case, just continue with the next chapter.

If your module IS NOT an item, should be an implement of Phprojekt_Model_Interface with the next functions defined:

[emph]public function getInformation()[/emph]

Returns an object that implements the model information interface
and that provides detailed information about the fields and their types.

[emph]public function find()[/emph]

Find a dataset, usually by an id.
If the record is found the current object is filled with the data and returns itself.

[emph]public function fetchAll()[/emph]

Fetch a set of records.
Depending on the implementation it might be possible to limit the fetch by e.g. providing a where clause.
A model do not need to implement a limiting mechanism.

[emph]public function save()[/emph]

Save the current object to the back end.

[emph]public function recordValidate()[/emph]

Validate the data of the current record.

[emph]public function getRights()[/emph]

Get the rights for other users.

[emph]Without extension[/emph]

If your module is not an extension of any class, you must define AT LEAST a fetchAll function like
[code]
public function fetchAll()
{
    return array();
}
[/code]

This is because when you delete a project, the routine will call a fetchAll on each module associate to the project.

[emph]Clone[/emph]

If your module have internal variables with other classes like for example:

$this->_validate = Phprojekt_Loader::getLibraryClass('Phprojekt_Model_Validate');

You must define a __clone function for re-assign the class to the var, or the class will not work.
The clone is called by the cache.
The Phprojekt_Item_Abstract class already do that.
